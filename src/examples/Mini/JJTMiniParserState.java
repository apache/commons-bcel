/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */
/* Generated By:JJTree: Do not edit this line. JJTMiniParserState.java */

package Mini;

class JJTMiniParserState {
    private final java.util.Stack<Node> nodes;
    private final java.util.Stack<Integer> marks;

    private int sp; // number of nodes on stack
    private int mk; // current mark
    private boolean node_created;

    JJTMiniParserState() {
        nodes = new java.util.Stack<>();
        marks = new java.util.Stack<>();
        sp = 0;
        mk = 0;
    }

    void clearNodeScope(final Node n) {
        while (sp > mk) {
            popNode();
        }
        mk = marks.pop().intValue();
    }

    /*
     * A conditional node is constructed if its condition is true. All the nodes that have been pushed since the node was
     * opened are made children of the conditional node, which is then pushed on to the stack. If the condition is false
     * the node is not constructed and they are left on the stack.
     */
    void closeNodeScope(final Node n, final boolean condition) {
        if (condition) {
            int a = nodeArity();
            mk = marks.pop().intValue();
            while (a-- > 0) {
                final Node c = popNode();
                c.jjtSetParent(n);
                n.jjtAddChild(c, a);
            }
            n.jjtClose();
            pushNode(n);
            node_created = true;
        } else {
            mk = marks.pop().intValue();
            node_created = false;
        }
    }

    /*
     * A definite node is constructed from a specified number of children. That number of nodes are popped from the stack
     * and made the children of the definite node. Then the definite node is pushed on to the stack.
     */
    void closeNodeScope(final Node n, int num) {
        mk = marks.pop().intValue();
        while (num-- > 0) {
            final Node c = popNode();
            c.jjtSetParent(n);
            n.jjtAddChild(c, num);
        }
        n.jjtClose();
        pushNode(n);
        node_created = true;
    }

    /*
     * Returns the number of children on the stack in the current node scope.
     */
    int nodeArity() {
        return sp - mk;
    }

    /*
     * Determines whether the current node was actually closed and pushed. This should only be called in the final user
     * action of a node scope.
     */
    boolean nodeCreated() {
        return node_created;
    }

    void openNodeScope(final Node n) {
        marks.push(Integer.valueOf(mk));
        mk = sp;
        n.jjtOpen();
    }

    /* Returns the node currently on the top of the stack. */
    Node peekNode() {
        return nodes.peek();
    }

    /*
     * Returns the node on the top of the stack, and remove it from the stack.
     */
    Node popNode() {
        if (--sp < mk) {
            mk = marks.pop().intValue();
        }
        return nodes.pop();
    }

    /* Pushes a node on to the stack. */
    void pushNode(final Node n) {
        nodes.push(n);
        ++sp;
    }

    /*
     * Call this to reinitialize the node stack. It is called automatically by the parser's ReInit() method.
     */
    void reset() {
        nodes.removeAllElements();
        marks.removeAllElements();
        sp = 0;
        mk = 0;
    }

    /*
     * Returns the root node of the AST. It only makes sense to call this after a successful parse.
     */
    Node rootNode() {
        return nodes.elementAt(0);
    }
}
